---
alwaysApply: true
---

# Cursor Rules for Krapi Project

## Most Important rules overview

- Every connection from outside using this app needs to go through the frontend
- Connection scheme: Client app -> Frontend manager -> Backend / Database / File storage operation -> Response to frontend manager -> Response to client.
- All connections between frontend manager and backend are made using SDK methods that are compatible with each other.

## Architecture Rules

### 1. Separation of Concerns

- Separate functions and components into different files to better track points of failure
- Each file should have a single, clear responsibility
- Use proper file organization and naming conventions

### 2. Type Safety

- Everything needs to be type safe with specified types
- Functions that mutate data, create new data, or request data must clearly specify:
  - What kind of data they expect to receive
  - What kind of data they will return
- This allows different parts of the code to be connectable like LEGO blocks with matching data types
- NO `any` types allowed - use proper TypeScript types

### 3. Normalization of Coding Style

- Use consistent style across all parts of the application
- Keep code clean, elegant, and consistent
- Examples of what needs to be consistent:
  - API route writing patterns
  - Mutation function patterns
  - Async/API request patterns and libraries used
  - Data transfer methodology
  - Error handling patterns
  - Logging patterns

### 4. Code Cleanliness

- **NEVER comment out unused variables, imports, or code**
- **ALWAYS delete unused variables, imports, and dead code completely**
- Unused code creates confusion and maintenance overhead
- If code might be needed later, use version control (git) to track it, not comments
- Keep the codebase clean and production-ready at all times

### 5. NO MOCK FUNCTIONALITY - REAL IMPLEMENTATIONS ONLY

**CRITICAL: Mock functionality is completely banned and forbidden.**

- **NEVER create mock functions, mock data, or mock implementations**
- **NEVER use placeholder code that doesn't actually work**
- **NEVER create fake database connections or fake API responses**
- **ALWAYS implement real, functional code that performs actual operations**
- **If you can't implement the real functionality immediately, don't create anything**
- **Mock code is banned, forbidden, and completely unacceptable**
- **Every function must do what it claims to do - no fake implementations**
- **No "TODO: implement later" or "placeholder" code allowed**

### 6. SDK-DRIVEN ARCHITECTURE - SINGLE SOURCE OF TRUTH

**CRITICAL: The SDK controls BOTH frontend and backend - no duplicate implementations.**

#### Frontend SDK Usage Pattern:

#### Benefits:

- **Single source of truth** - functionality exists only in SDK
- **Type safety guaranteed** - frontend and backend use same interfaces
- **Built-in error handling** - SDK provides comprehensive error responses
- **No implementation mismatches** - backend can't exist without SDK
- **Automatic validation** - SDK validates all inputs and outputs
- **Consistent error messages** - SDK provides standardized error responses

#### Error Handling:

- **Database errors** - SDK catches and formats database-specific errors
- **Missing endpoints** - SDK detects when frontend requests unimplemented functionality
- **Input validation** - SDK validates all data before processing
- **Type mismatches** - SDK ensures frontend/backend type compatibility
- **Network errors** - SDK handles connection and timeout issues

#### Implementation Flow:

1. **SDK defines the method** (e.g., `collections.get()`)
2. **Frontend imports and calls** the SDK method
3. **Backend creates route** using `backendSDK.collections.createRoute('get')`
4. **SDK handles everything** - validation, database calls, error handling, response formatting
5. **Backend just wires** the SDK method to the HTTP route

**REMEMBER: The SDK is not just a client library - it's the ENTIRE application logic. Backend is just HTTP routing, frontend is just UI. All business logic lives in the SDK.**

These ports are hardcoded throughout the application and changing them will break functionality. Always use these exact ports when developing, testing, or deploying this application.
