# Krapi CMS - Cursor Development Rules

## Project Overview
Krapi CMS is a modern, TypeScript-based headless CMS with a React admin panel. This project requires production-quality code with no placeholders or fake implementations.

## Core Development Principles

### ðŸš« ABSOLUTELY FORBIDDEN
- **NO PLACEHOLDERS**: Every button, feature, and function must be fully implemented
- **NO FAKE DATA**: All data must come from real API endpoints or database queries
- **NO TODO COMMENTS**: Replace with actual implementations immediately
- **NO LINTER ERRORS**: All TypeScript, ESLint, and other linting errors must be fixed before proceeding
- **NO BROKEN FUNCTIONALITY**: Every feature must work end-to-end

### âœ… REQUIRED STANDARDS
- **Full Implementation**: Every UI element must have complete backend support
- **Real Data Flow**: All data must flow from database â†’ API â†’ frontend
- **Working Buttons**: Every button must perform its intended action
- **Error Handling**: Proper error states and user feedback for all operations
- **TypeScript Strict**: No `any` types, proper interfaces and type safety
- **Responsive Design**: All UI must work on desktop and mobile

## Technology Stack Requirements

### Backend (Express.js + TypeScript)
- **Database**: SQLite with better-sqlite3
- **Authentication**: JWT tokens with proper validation
- **API Design**: RESTful endpoints with consistent response formats
- **Error Handling**: Proper HTTP status codes and error messages
- **Validation**: Input validation on all endpoints
- **Security**: SQL injection prevention, input sanitization

### Frontend (Next.js + React + TypeScript)
- **Routing**: App Router with proper page structure
- **State Management**: React hooks and context for auth
- **API Calls**: Axios with proper error handling
- **Forms**: React Hook Form with Zod validation
- **Styling**: Tailwind CSS with responsive design
- **Components**: Reusable, properly typed components

### Development Environment
- **Single Launcher**: Use `UnifiedDev.bat` for starting all services
- **Port Management**: API (3001), Frontend (3000), Control Panel (4000)
- **Logging**: Proper error logging and debugging information

## Implementation Requirements

### Database Operations
```typescript
// âœ… REQUIRED: Real database queries
const users = database.getAllUsers();

// ðŸš« FORBIDDEN: Fake data
const users = [{ id: 1, name: "fake user" }];
```

### API Endpoints
```typescript
// âœ… REQUIRED: Full implementation with error handling
export async function GET(req: Request) {
  try {
    const data = await database.getData();
    return Response.json({ success: true, data });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 500 });
  }
}

// ðŸš« FORBIDDEN: Mock responses
export async function GET(req: Request) {
  return Response.json({ success: true, data: "mock data" });
}
```

### React Components
```typescript
// âœ… REQUIRED: Working button with real functionality
const handleDelete = async (id: number) => {
  try {
    await api.delete(`/users/${id}`);
    setUsers(users.filter(u => u.id !== id));
    showNotification("User deleted successfully");
  } catch (error) {
    showNotification("Failed to delete user", "error");
  }
};

// ðŸš« FORBIDDEN: Placeholder functions
const handleDelete = (id: number) => {
  console.log("TODO: Implement delete");
};
```

## Code Quality Standards

### TypeScript Requirements
- Enable strict mode in `tsconfig.json`
- Define explicit interfaces for all data structures
- No `any` types - use proper typing or `unknown` with type guards
- Generic types where appropriate
- Proper error type handling

### Linting Rules
- **Zero Tolerance**: Fix ALL linting errors before committing
- Use ESLint with recommended React and TypeScript rules
- Prettier for consistent formatting
- No unused variables or imports
- Proper naming conventions (camelCase, PascalCase, etc.)

### Error Handling Patterns
```typescript
// âœ… REQUIRED: Comprehensive error handling
try {
  const result = await apiCall();
  if (!result.success) {
    throw new Error(result.error);
  }
  return result.data;
} catch (error) {
  if (axios.isAxiosError(error)) {
    // Handle network errors
  } else {
    // Handle other errors
  }
  throw error;
}

// ðŸš« FORBIDDEN: Silent failures
try {
  await apiCall();
} catch {
  // Ignoring errors
}
```

## Feature Implementation Checklist

### Before marking any feature "complete":
- [ ] Backend API endpoint exists and works
- [ ] Database operations are implemented
- [ ] Frontend makes real API calls
- [ ] Error states are handled
- [ ] Loading states are implemented
- [ ] Success feedback is provided
- [ ] All TypeScript types are defined
- [ ] No linter errors exist
- [ ] Manual testing confirms functionality

### UI Component Requirements
- [ ] All buttons perform their stated actions
- [ ] Forms submit real data to backend
- [ ] Tables display real data from database
- [ ] Modals open/close properly
- [ ] Navigation works between all pages
- [ ] Responsive design on all screen sizes

### API Integration Requirements
- [ ] All endpoints return consistent response format
- [ ] Authentication is properly implemented
- [ ] CRUD operations work end-to-end
- [ ] Error responses include helpful messages
- [ ] Input validation prevents invalid data

## Testing Requirements

### Manual Testing
- Test every button and form in the UI
- Verify data persists after page refresh
- Test error scenarios (invalid input, network failures)
- Verify authentication flows work properly
- Test responsive design on different screen sizes

### Development Testing
- Use browser dev tools to verify API calls
- Check database directly to confirm data changes
- Monitor console for any JavaScript errors
- Verify WebSocket connections in control panel

## Common Patterns to Follow

### API Response Format
```typescript
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}
```

### Error Boundary Pattern
```typescript
// Always wrap async operations
const [loading, setLoading] = useState(false);
const [error, setError] = useState("");

const handleAction = async () => {
  setLoading(true);
  setError("");
  try {
    await performAction();
    showSuccessMessage();
  } catch (err) {
    setError(err.message);
  } finally {
    setLoading(false);
  }
};
```

### Form Validation Pattern
```typescript
// Use react-hook-form with zod validation
const form = useForm<FormData>({
  resolver: zodResolver(schema),
});

const onSubmit = async (data: FormData) => {
  // Submit to real API endpoint
  const result = await api.post('/endpoint', data);
  if (result.success) {
    // Handle success
  }
};
```

## File Organization

### Keep this structure:
```
/api-server          # Backend Express.js application
  /src
    /controllers     # API route handlers
    /services        # Business logic and database operations
    /middleware      # Auth, validation middleware
    /types           # TypeScript type definitions

/admin-frontend      # Frontend Next.js application
  /app              # App router pages
  /components       # Reusable React components
  /lib              # Utilities and API client
  /types            # TypeScript type definitions

/development         # Development tools
  /dev-control      # Web-based control panel

/logs               # Application logs
launcher.js         # Development launcher script
UnifiedDev.bat     # Single-click development startup
```

## Performance Requirements

- Database queries should be optimized
- API responses should be under 200ms for simple operations
- Frontend should load in under 3 seconds
- No memory leaks in long-running processes
- Proper cleanup of WebSocket connections

## Security Requirements

- All API endpoints require proper authentication
- Input validation on all user data
- SQL injection prevention
- XSS protection
- Secure password handling with bcrypt

## Documentation Requirements

- JSDoc comments for all public functions
- README files must be accurate and up-to-date
- API endpoints should be self-documenting
- Complex business logic should have inline comments

## Deployment Readiness

All code must be production-ready:
- Environment variables for configuration
- Proper error logging
- Database migrations (if needed)
- No development-only code in production paths
- Proper build processes for both frontend and backend

---

**Remember: Every feature must work completely. No exceptions, no placeholders, no "TODO" items. If you implement it, it must work end-to-end.** 